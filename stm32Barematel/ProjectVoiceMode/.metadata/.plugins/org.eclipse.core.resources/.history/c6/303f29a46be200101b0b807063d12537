#include "stm32f446xx.h"
#include "stm32f446xx_gpio_driver.h"
#include "stm32f446xx_rcc_driver.h"
#include "stm32f446xx_usart_driver.h"
#include <stdint.h>
#include <stdio.h>

#define TRIG_PIN   GPIO_PIN_NO_0   // PA0
#define ECHO_PIN   GPIO_PIN_NO_1   // PA1
#define LED_PIN    GPIO_PIN_NO_5   // PA5 (Onboard LED)

#define DISTANCE_THRESHOLD_CM  2   // LED ON when distance < 2 cm

USART_Handle_t usart2_handle;     // USART2 handle

// crude delay (approx microseconds)
void delay_us(uint32_t us)
{
    for (volatile uint32_t i = 0; i < us * 10; i++);
}

// measure distance in cm
uint32_t measure_distance_cm(void)
{
    uint32_t timeout = 30000;

    GPIO_WriteToOutputPin(GPIOA, TRIG_PIN, GPIO_PIN_RESET);
    delay_us(2);
    GPIO_WriteToOutputPin(GPIOA, TRIG_PIN, GPIO_PIN_SET);
    delay_us(10);
    GPIO_WriteToOutputPin(GPIOA, TRIG_PIN, GPIO_PIN_RESET);

    while (!GPIO_ReadFromInputPin(GPIOA, ECHO_PIN))
    {
        if (timeout-- == 0) return 0;
    }

    uint32_t count = 0;
    timeout = 30000;
    while (GPIO_ReadFromInputPin(GPIOA, ECHO_PIN))
    {
        count++;
        delay_us(1);
        if (timeout-- == 0) break;
    }

    return (count * 34) / 2000;
}

// Initialize USART2 for 9600, 8N1
void USART2_Init(void)
{
    usart2_handle.pUSARTx = USART2;
    usart2_handle.USART_Config.USART_Baud = 9600;
    usart2_handle.USART_Config.USART_HWFlowControl = USART_HW_FLOW_CTRL_NONE;
    usart2_handle.USART_Config.USART_Mode = USART_MODE_ONLY_TX;

    usart2_handle.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
    usart2_handle.USART_Config.USART_WordLength = USART_WORDLEN_8BITS;
    usart2_handle.USART_Config.USART_NoOfStopBits = USART_STOPBITS_1;

    USART_Init(&usart2_handle);
    USART_PeripheralControl(USART2, ENABLE);
}

// send string over USART
void USART_SendString(USART_Handle_t *pUSARTx, char *str)
{
    while (*str)
    {
        USART_SendData(pUSARTx, (uint8_t*)str, 1);
        str++;
    }
}

int main(void)
{
    GPIO_PeriClockControl(GPIOA, ENABLE);

    // --- TRIG PIN ---
    GPIO_Handle_t GpioTrig = {0};
    GpioTrig.pGPIOx = GPIOA;
    GpioTrig.GPIO_PinConfig.GPIO_PinNumber = TRIG_PIN;
    GpioTrig.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
    GpioTrig.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
    GpioTrig.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    GpioTrig.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    GPIO_Init(&GpioTrig);

    // --- ECHO PIN ---
    GPIO_Handle_t GpioEcho = {0};
    GpioEcho.pGPIOx = GPIOA;
    GpioEcho.GPIO_PinConfig.GPIO_PinNumber = ECHO_PIN;
    GpioEcho.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
    GpioEcho.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
    GpioEcho.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    GPIO_Init(&GpioEcho);

    // --- LED PIN ---
    GPIO_Handle_t GpioLed = {0};
    GpioLed.pGPIOx = GPIOA;
    GpioLed.GPIO_PinConfig.GPIO_PinNumber = LED_PIN;
    GpioLed.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
    GpioLed.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
    GpioLed.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    GpioLed.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    GPIO_Init(&GpioLed);

    USART2_Init();

    while (1)
    {
        uint32_t distance = measure_distance_cm();

        if (distance < DISTANCE_THRESHOLD_CM)
        {
            GPIO_WriteToOutputPin(GPIOA, LED_PIN, GPIO_PIN_SET);
            USART_SendString(&usart2_handle, "DANGER\n");
        }
        else
        {
            GPIO_WriteToOutputPin(GPIOA, LED_PIN, GPIO_PIN_RESET);
        }

        for (volatile uint32_t i = 0; i < 200000; i++);
    }
}
